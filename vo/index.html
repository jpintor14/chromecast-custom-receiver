<!DOCTYPE html>
<html>
<head>
    <title>QuickPlayer Custom Receiver</title>

    <link rel="stylesheet" type="text/css" href="style.css">

    <script src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>
    <script src="//www.gstatic.com/cast/sdk/libs/mediaplayer/1.0.0/media_player.js"></script>
</head>
<body>
    <!-- Splash screen elements -->
    <div id="splash_screen" class="sqp-screen">
        <img id="splash_image" class="sqp-center" />
    </div>

    <!-- Load screen elements -->
    <div id="load_screen" class="sqp-screen">
        <img id="load_image" class="sqp-loading-img-anim sqp-center" />
    </div>

    <!-- Player screen elements -->
    <div id="player_screen" class="sqp-screen">
        <div id="video-container">
            <video id="media" width="100%" height="100%"/>
        </div>
        <div id="media_overlay">
            <div id="poster-container">
                <img id="poster_image" />
            </div>
            <h1 id="mediaTitle">Media Title</h1>
        </div>
        <div id="playback_overlay">
            <div id="media_current_time">00:00:00</div>
            <div class="sqp-overlay-noautohide sqp-progressbar" >
                <div class="sqp-progressbar-background pointer-cursor">
                    <div id="progress_bar_progress" class="sqp-progressbar-progress sqp-progressbar-progress-play sqp-ui-main-bgcolor">
                        <div class="sqp-progressbar-progress-endpoint sqp-ui-main-bgcolor"></div>
                    </div>
                </div>
            </div>
            <div id="media_duration">00:00:00</div>
        </div>
        <div id="logo-container">
            <img id="logo_image" />
        </div>
    </div>

    <!-- Error screen elements -->
    <div id="error_screen" class="sqp-screen">
        <img id="error_image" class="sqp-center" />
        <div id="playerError" class="sqp-center">
            <h1>Error : <span id="player_error"> 0x404 </span></h1>
        </div>
    </div>

    <!-- Popup Status elements -->
    <div id="status_notification" class="sqp-popup">
        <h2>Player status<div id="player_status"> ... </div></h2>
    </div>

    <script>
    'use strict';
    // Const
    const SQP_COMMUNICATION_CHANNEL_URN           = 'urn:x-cast:com.viaccess.voplayer';
    const SQP_RECEIVER_MEDIA_OVERLAY_TIMER        = 15000;
    const SQP_RECEIVER_NOTIFICATION_OVERLAY_TIMER = 2000;
    const SQP_PROGRESS_BAR_OVERLAY_TIMER          = 10000;

    const SPLASH_SCREEN_SRC = './images/splash_viaccess.png';
    const OVERLAY_LOGO_SRC  = './images/logo_viaccess.png';
    const LOADING_WHEEL_SRC = './images/loading_viaccess.png';

    // This one should be dynamic on a real application
    const POSTER_IMAGE_SRC =  './images/poster_bbb.jpg';

    // Screens variables
    var screenController = null;
    var screens = null;
    var splashScreen = null;
    var loadScreen = null;
    var playerScreen = null;
    var errorScreen = null;
    var statusNotification = null;
    var mediaOverlay = null;
    var playbackOverlay = null;
    var playerErrorSpan = null;

    var progressbarProgress_ = null;
    var mediaCurrentTime_ = null;
    var mediaDuration_ = null;

    // DRM variables
    var licenseUrl;
    var licenseCustomData;

    /* This controls which screen is currently being displayed */
    function sqpScreenController(elements) {
        this.screens = elements;
    }

    /* This function is used to show specific screen */
    sqpScreenController.prototype.showScreen = function(newScreen) {
        if (this.currentScreen === newScreen) {
            return;
        }

        for (var idx in this.screens) {
            if (this.screens[idx] !== newScreen) {
                this.screens[idx].style.display = 'none';
            }
        }
        newScreen.style.display = 'block';
        this.currentScreen = newScreen;
    }


    cast.player.api.setLoggerLevel(cast.player.api.LoggerLevel.WARNING);
    window.mediaElement = document.getElementById('media');
    window.mediaManager = new cast.receiver.MediaManager(window.mediaElement);

    mediaElement.addEventListener('ended', function() {
        console.log('Media ended !');
        screenController.showScreen(splashScreen);

        var endStreamMsg = {type: 'mediaended'};
        voplayerMessageBus.broadcast(JSON.stringify(endStreamMsg));
    });

    mediaElement.addEventListener('stop', function() {
        console.log('Media stopped !');
        screenController.showScreen(splashScreen);
    });

    mediaElement.addEventListener('error', function() {
        console.log('Media error !');
        screenController.showScreen(splashScreen);
    });

    mediaElement.addEventListener('loadedmetadata', function() {
        console.log('Loaded Meta data');

        var protocol = player.getStreamingProtocol();
        var streamCount = protocol.getStreamCount();
        var streamInfo;

        var audioTracks = [];
        var videoTracks = [];
        var textTracks = [];

        for (var i = 0; i < streamCount; i++) {
            var streamInfo = protocol.getStreamInfo(i);
            var enabled = protocol.isStreamEnabled(i);
            streamInfo.enabled = enabled;
            streamInfo.trackID = i;
            if (streamInfo.name == null) {
                if (streamInfo.role !== null) {
                    streamInfo.name = streamInfo.language + '-' + streamInfo.role;
                } else {
                    streamInfo.name = streamInfo.language + '-' + i;
                }
			}

            if(streamInfo.mimeType.indexOf('audio') === 0) {
                audioTracks.push(streamInfo);
            }
            else if (streamInfo.mimeType.indexOf('video') === 0) {
                videoTracks.push(streamInfo);
            }
            else if (streamInfo.mimeType.indexOf('text') === 0) {
                textTracks.push(streamInfo);
            }
            else if (streamInfo.mimeType.indexOf('application') === 0) {
                textTracks.push(streamInfo);
            }
            console.log('streamInfo ' + i  + ' : ' , streamInfo);
        }

        var tracksMsg = {type: 'tracksloaded'};
        tracksMsg.audioTracks = audioTracks;
        tracksMsg.videoTracks = videoTracks;
        tracksMsg.textTracks = textTracks;

        console.log('tracksMsg : ' , tracksMsg);

        voplayerMessageBus.broadcast(JSON.stringify(tracksMsg));
    });

    mediaElement.addEventListener('play', function() {
        screenController.showScreen(playerScreen);
        notifyStatus('Playing...');

        playbackOverlay.style.display = 'block';
        var timer = setInterval(function () {
            clearInterval(timer);
            playbackOverlay.style.display = 'none';
        }, SQP_PROGRESS_BAR_OVERLAY_TIMER);
    });

    mediaElement.addEventListener('timeupdate', function() {
        var pct = (100 * this.currentTime) / this.duration;
        var curHour = parseInt(this.currentTime / 3600);
        var curMin = parseInt((this.currentTime - curHour * 3600) / 60);
        var curSec = parseInt(this.currentTime % 60);
        var durHour = parseInt(this.duration / 3600);
        var durMin = parseInt((this.duration - durHour * 3600) / 60);
        var durSec = parseInt(this.duration % 60);

        progressbarProgress_.style.width = pct + '%';
        mediaCurrentTime_.innerHTML = ('0' + curHour).slice(-2) + ':' + ('0' + curMin).slice(-2) + ':' + ('0' + curSec).slice(-2);
        mediaDuration_.innerHTML = ('0' + durHour).slice(-2) + ':' + ('0' + durMin).slice(-2) + ':' + ('0' + durSec).slice(-2);
    });

    mediaElement.addEventListener('pause', function() {
        if (player.getState().underflow) {
            // video is paused because of buffering
            // handing buffering event here
            notifyStatus('Buffering...');
        } else {
            // video is paused for the other reason.
            notifyStatus('Paused...');
            playbackOverlay.style.display = 'block';
        }
    });

    mediaElement.addEventListener('waiting', function() {
        notifyStatus('Waiting...');
    });

    var statusHidingTimeout;

    function notifyStatus(status) {
        if(statusHidingTimeout) {
            clearTimeout(statusHidingTimeout);
            statusHidingTimeout = undefined;
        }
        playerStatus.innerHTML = status;
        statusNotification.style.display = 'block';
        statusHidingTimeout = setTimeout(function () {
            statusNotification.style.display = 'none';
        }, SQP_RECEIVER_NOTIFICATION_OVERLAY_TIMER);
    }


    // Remember the default value for the Receiver onLoad, so this sample can Play
    // non-adaptive media as well.
    window.defaultOnLoad = mediaManager.onLoad.bind(mediaManager)

    // Be careful that 'this' points to the mediaManager object and not the window object.
    // For example, if you're not using streaming media, the following line:
    // window.defaultOnLoad = mediaManager.onLoad;
    // Can return an exception similar to the following:
    // Uncaught TypeError: Cannot read property 'load' of undefined
    mediaManager.onLoad = function (event) {

        screenController.showScreen(loadScreen);
        notifyStatus('Loading...');

        // The Media Player Library requires that you call player unload between
        // different invocations.
        if (window.player !== null) {
            player.unload();    // Must unload before starting again.
            window.player = null;
        }

        // This trivial parser is by no means best practice, it shows how to access
        // event data, and uses the a string search of the suffix, rather than looking
        // at the MIME type which would be better.  In practice, you will know what
        // content you are serving while writing your player.
        if (event.data['media'] && event.data['media']['contentId']) {
            console.log('Starting media application');
            var url = event.data['media']['contentId'];
            // Create the Host - much of your interaction with the library uses the Host and
            // methods you provide to it.
            window.host = new cast.player.api.Host({'mediaElement':mediaElement, 'url':url});

            var ext = url.substring(url.lastIndexOf('.'), url.length);
            var initStart = event.data['media']['currentTime'] || 0;
            var autoplay = event.data['autoplay'] || true;
            window.protocol_ = null;
            mediaElement.autoplay = autoplay;  // Make sure autoplay get's set

            // Setting DRM info if any
            host.licenseUrl = licenseUrl;
            host.licenseCustomData = licenseCustomData;

            if (url.lastIndexOf('.m3u8') >= 0) {
                // HTTP Live Streaming
                window.protocol_ = cast.player.api.CreateHlsStreamingProtocol(host);
            } else if (url.lastIndexOf('.mpd') >= 0) {
                // MPEG-DASH
                window.protocol_ = cast.player.api.CreateDashStreamingProtocol(host);
            } else if (url.indexOf('.ism/') >= 0) {
                // Smooth Streaming
                window.protocol_ = cast.player.api.CreateSmoothStreamingProtocol(host);
            }


            // If you need cookies, then set withCredentials = true also set any header
            // information you need.  If you don't need them, there can be some unexpected
            // effects by setting this value.
            //      host.updateSegmentRequestInfo = function(requestInfo) {
            //        requestInfo.withCredentials = true;
            //      };

            host.updateManifestRequestInfo = function(requestInfo) {
                console.log('VOPlayer updateManifestRequestInfo INFO', requestInfo);
                // requestInfo.withCredentials = true;
            };

            host.updateSegmentRequestInfo = function(requestInfo) {
                console.log('VOPlayer updateSegmentRequestInfo INFO', requestInfo);
                /* withCredentials must be used if you need cookies handling,
                however it CANNOT be used on servers configured with '*' as Allow-Origin CORS header */
                // requestInfo.withCredentials = true;
            };

            host.updateLicenseRequestInfo = function(requestInfo) {
                console.log('VOPlayer updateLicenseRequestInfo INFO', requestInfo);
                /* withCredentials must be used if you need cookies handling,
                however it CANNOT be used on servers configured with '*' as Allow-Origin CORS header */
                // requestInfo.withCredentials = true;
            }

            host.onError = function(errorCode) {
                console.log('Fatal Error - ' + errorCode);
                if (window.player) {
                    window.player.unload();
                    window.player = null;
                }
                playerErrorSpan.innerHTML = 'Playback error: ' + errorCode;
                screenController.showScreen(errorScreen);

                var errorMsg = {type: 'playbackerror'};
                errorMsg.errorCode = errorCode;
                voplayerMessageBus.broadcast(JSON.stringify(errorMsg));
            };

            console.log('we have protocol ' + ext);
            if (window.protocol_ !== null) {
                console.log('Starting Media Player Library');
                window.player = new cast.player.api.Player(host);
                window.player.load(window.protocol_, initStart);
            }
            else {
                window.defaultOnLoad(event);    // do the default process
            }
        }
    }

    window.player = null;
    console.log('Application is ready, starting system');

    document.getElementById('splash_image').src = SPLASH_SCREEN_SRC;
    document.getElementById('logo_image').src = OVERLAY_LOGO_SRC;
    document.getElementById('load_image').src = LOADING_WHEEL_SRC;

    splashScreen = document.querySelector('#splash_screen');
    loadScreen = document.querySelector('#load_screen');
    playerScreen = document.querySelector('#player_screen');
    errorScreen = document.querySelector('#error_screen');
    screens = [ splashScreen, loadScreen, playerScreen, errorScreen ];
    screenController = new sqpScreenController(screens);


    var playerStatus = document.getElementById('player_status');

    playerErrorSpan = document.getElementById('player_error');

    screenController.showScreen(splashScreen);

    document.getElementById('poster_image').src = POSTER_IMAGE_SRC;

    progressbarProgress_ = document.querySelector('#progress_bar_progress');
    mediaCurrentTime_ = document.querySelector('#media_current_time');
    mediaDuration_ = document.querySelector('#media_duration');

    statusNotification = document.querySelector('#status_notification');
    mediaOverlay = document.querySelector('#media_overlay');
    playbackOverlay = document.querySelector('#playback_overlay');

    window.castReceiverManager = cast.receiver.CastReceiverManager.getInstance();

    /**
    * Application config
    **/
    var appConfig = new cast.receiver.CastReceiverManager.Config();

    /**
    * Text that represents the application status. It should meet
    * internationalization rules as may be displayed by the sender application.
    * @type {string|undefined}
    **/
    appConfig.statusText = 'QuickPlayer on ChromeCast';

    /**
    * Maximum time in seconds before closing an idle
    * sender connection. Setting this value enables a heartbeat message to keep
    * the connection alive. Used to detect unresponsive senders faster than
    * typical TCP timeouts. The minimum value is 5 seconds, there is no upper
    * bound enforced but practically it's minutes before platform TCP timeouts
    * come into play. Default value is 10 seconds.
    * @type {number|undefined}
    **/
    // 10 minutes for testing, use default 10sec in prod by not setting this value
    appConfig.maxInactivity = 600;
    /**
    * Initializes the system manager. The application should call this method when
    * it is ready to start receiving messages, typically after registering
    * to listen for the events it is interested on.
    */

    window.castReceiverManager.onSenderDisconnected = function(event) {
        console.log('sender disconnected, ', event);
        screenController.showScreen(splashScreen);

        if(window.castReceiverManager.getSenders().length == 0 &&
        event.reason == cast.receiver.system.DisconnectReason.REQUESTED_BY_SENDER) {
            window.close();
        }
    }

    // create dedicated voplayer message bus
    var voplayerMessageBus = castReceiverManager.getCastMessageBus(SQP_COMMUNICATION_CHANNEL_URN);
    voplayerMessageBus.onMessage = function(event) {
        // Handle message
        console.log(event.data);
        try {
            var msg = JSON.parse(event.data);
            var streamInfo;
            console.log('json parse ok');

            // Set media title
            if (msg.hasOwnProperty('setMediaTitle')) {
                console.log('Setting media title');
                document.getElementById('mediaTitle').innerHTML = msg.setMediaTitle;

                mediaOverlay.style.display = 'block';
                var timer = setInterval(function () {
                    clearInterval(timer);
                    mediaOverlay.style.display = 'none';
                }, SQP_RECEIVER_MEDIA_OVERLAY_TIMER);
            }

            // Subtitle tracks
            if (msg.hasOwnProperty('setSubtitleTrack')) {
                var currentLanguage = null;
                var protocol = player.getStreamingProtocol();
                var streamCount = protocol.getStreamCount();
                var reloadPlayer = false;
                console.log('Setting subtitle track by ID');

                // Disabling previous subtitle tracks
                for (var i = 0; i < streamCount; i++) {
                    if (protocol.isStreamEnabled(i)) {
                        streamInfo = protocol.getStreamInfo(i);
                        if (streamInfo.mimeType.indexOf('text') === 0) {
                            protocol.enableStream(i, false);
                            reloadPlayer = true;
                        } else if (streamInfo.mimeType.indexOf('application') === 0) {
                            protocol.enableStream(i, false);
                            reloadPlayer = true;
                        }
                    }
                }

                streamInfo = protocol.getStreamInfo(msg.setSubtitleTrack);
                if (streamInfo.mimeType.indexOf('text') === 0) {
                    protocol.enableStream(msg.setSubtitleTrack, true);
                    reloadPlayer = true;
                } else if (streamInfo.mimeType.indexOf('application') === 0) {
                    protocol.enableStream(msg.setSubtitleTrack, true);
                    reloadPlayer = true;
                }

                if (reloadPlayer) {
                    player.reload();
                }
            }

            // Audio tracks
            if (msg.hasOwnProperty('setAudioTrack')) {
                var currentLanguage = null;
                var protocol = player.getStreamingProtocol();
                var streamCount = protocol.getStreamCount();
                console.log('Setting audio track by ID');

                // Disabling previous audio tracks
                for (var i = 0; i < streamCount; i++) {
                    if (protocol.isStreamEnabled(i)) {
                        streamInfo = protocol.getStreamInfo(i);
                        if (streamInfo.mimeType.indexOf('audio') === 0) {
                            protocol.enableStream(i, false);
                        }
                    }
                }

                streamInfo = protocol.getStreamInfo(msg.setAudioTrack);
                if (streamInfo.mimeType.indexOf('audio') === 0) {
                    protocol.enableStream(msg.setAudioTrack, true);
                }
                player.reload();
            }
            // Set license URL
            if (msg.hasOwnProperty('setLicenseUrl')) {
                licenseUrl = msg.setLicenseUrl;
            }
            // Set license Custom Data
            if (msg.hasOwnProperty('setLicenseCustomData')) {
                licenseCustomData = msg.setLicenseCustomData;
            }
            // Release the player, may be required for some platforms when ending playback
            if (msg.hasOwnProperty('stopRemotePlayer')) {
                player.unload();
                screenController.showScreen(splashScreen);
            }
        }
        catch(e) {
            console.log('error message', e);
        }
    }

    window.castReceiverManager.start(appConfig);

    </script>
</body>
</html>
