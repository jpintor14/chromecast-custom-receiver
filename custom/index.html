<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="stylesheet" href="receiver.css" media="screen" />
</head>
<body>

    <cast-media-player id="player"></cast-media-player>
    <!--    <script type="text/javascript" src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"> </script> -->
    <script type="text/javascript" src="cast_receiver_framework2.5.0.js"> </script>

    <script>
        /**
        * <p>
        * This defines the default text displayer plugin. An instance of this
        * class is used when no custom displayer is given.
        * </p>
        * <p>
        * This class simply converts shaka.text.Cue objects to
        * TextTrackCues and feeds them to the browser.
        * </p>
        *
        * @param {HTMLMediaElement} video
        * @constructor
        * @struct
        * @implements {shaka.extern.TextDisplayer}
        * @export
        */
        CustomTextDisplayer = function(video) {
        /** @private {TextTrack} */
        this.textTrack_ = null;
        // TODO: Test that in all cases, the built-in CC controls in the video element
        // are toggling our TextTrack.
        // If the video element has TextTracks, disable them.  If we see one that
        // was created by a previous instance of Shaka Player, reuse it.
        for (let i = 0; i < video.textTracks.length; ++i) {
        let track = video.textTracks[i];
        track.mode = 'disabled';
        if (track.label == CustomTextDisplayer.TextTrackLabel_) {
            this.textTrack_ = track;
        }
        }
        if (!this.textTrack_) {
        // As far as I can tell, there is no observable difference between setting
        // kind to 'subtitles' or 'captions' when creating the TextTrack object.
        // The individual text tracks from the manifest will still have their own
        // kinds which can be displayed in the app's UI.
        this.textTrack_ = video.addTextTrack(
            'subtitles', CustomTextDisplayer.TextTrackLabel_);
        }
        this.textTrack_.mode = 'hidden';
    };
    /**
        * @override
        * @export
        */
    CustomTextDisplayer.prototype.remove = function(start, end) {
        // Check that the displayer hasn't been destroyed.
        if (!this.textTrack_) return false;
        let removeInRange = (cue) => {
        const inside = cue.startTime < end && cue.endTime > start;
        return inside;
        };
        CustomTextDisplayer.removeWhere_(this.textTrack_, removeInRange);
        return true;
    };
    /**
        * @override
        * @export
        */
    CustomTextDisplayer.prototype.append = function(cues) {
        const convertToTextTrackCue =
            CustomTextDisplayer.convertToTextTrackCue_;
        // Convert cues.
        let textTrackCues = [];
        for (let i = 0; i < cues.length; i++) {
        let cue = convertToTextTrackCue(cues[i]);
        if (cue) {
            textTrackCues.push(cue);
        }
        }
        // Sort the cues based on start/end times.  Make a copy of the array so
        // we can get the index in the original ordering.  Out of order cues are
        // rejected by IE/Edge.  See https://bit.ly/2K9VX3s
        let sortedCues = textTrackCues.slice().sort(function(a, b) {
        if (a.startTime != b.startTime) {
            return a.startTime - b.startTime;
        } else if (a.endTime != b.endTime) {
            return a.endTime - b.startTime;
        } else {
            // The browser will display cues with identical time ranges from the
            // bottom up.  Reversing the order of equal cues means the first one
            // parsed will be at the top, as you would expect.
            // See https://github.com/google/shaka-player/issues/848 for more info.
            return textTrackCues.indexOf(b) - textTrackCues.indexOf(a);
        }
        });
        sortedCues.forEach(function(cue) {
        this.textTrack_.addCue(cue);
        }.bind(this));
    };
    /**
        * @override
        * @export
        */
    CustomTextDisplayer.prototype.destroy = function() {
        if (this.textTrack_) {
        let removeIt = (cue) => true;
        CustomTextDisplayer.removeWhere_(this.textTrack_, removeIt);
        }
        this.textTrack_ = null;
        return Promise.resolve();
    };
    /**
        * @override
        * @export
        */
    CustomTextDisplayer.prototype.isTextVisible = function() {
        return this.textTrack_.mode == 'showing';
    };
    /**
        * @override
        * @export
        */
    CustomTextDisplayer.prototype.setTextVisibility = function(on) {
        this.textTrack_.mode = on ? 'showing' : 'hidden';
    };
    /**
        * @param {!shaka.extern.Cue} shakaCue
        * @return {TextTrackCue}
        * @private
        */
    CustomTextDisplayer.convertToTextTrackCue_ = function(shakaCue) {
        if (shakaCue.startTime >= shakaCue.endTime) {
        // IE/Edge will throw in this case.
        // See issue #501
        shaka.log.warning('Invalid cue times: ' + shakaCue.startTime +
                            ' - ' + shakaCue.endTime);
        return null;
        }
        const Cue = shaka.text.Cue;
        /** @type {VTTCue} */
        let vttCue = new VTTCue(shakaCue.startTime,
                                shakaCue.endTime,
                                shakaCue.payload);
        // NOTE: positionAlign and lineAlign settings are not supported by Chrome
        // at the moment, so setting them will have no effect.
        // The bug on chromium to implement them:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=633690
        vttCue.lineAlign = shakaCue.lineAlign;
        vttCue.positionAlign = shakaCue.positionAlign;
        vttCue.size = shakaCue.size;
        try {
        // Safari 10 seems to throw on align='center'.
        vttCue.align = shakaCue.textAlign;
        } catch (exception) {}
        if (shakaCue.textAlign == 'center' && vttCue.align != 'center') {
        // We want vttCue.position = 'auto'. By default, |position| is set to
        // "auto". If we set it to "auto" safari will throw an exception, so we
        // must rely on the default value.
        vttCue.align = 'middle';
        }
        if (shakaCue.writingMode ==
                Cue.writingMode.VERTICAL_LEFT_TO_RIGHT) {
        vttCue.vertical = 'lr';
        } else if (shakaCue.writingMode ==
                Cue.writingMode.VERTICAL_RIGHT_TO_LEFT) {
        vttCue.vertical = 'rl';
        }
        // snapToLines flag is true by default
        if (shakaCue.lineInterpretation == Cue.lineInterpretation.PERCENTAGE) {
        vttCue.snapToLines = false;
        }
        if (shakaCue.line != null) {
        vttCue.line = shakaCue.line;
        }
        if (shakaCue.position != null) {
        vttCue.position = shakaCue.position;
        }
        return vttCue;
    };
    /**
        * Iterate over all the cues in a text track and remove all those for which
        * |predicate(cue)| returns true.
        *
        * @param {!TextTrack} track
        * @param {function(!TextTrackCue):boolean} predicate
        * @private
        */
    CustomTextDisplayer.removeWhere_ = function(track, predicate) {
        // Since |track.cues| can be null if |track.mode| is "disabled", force it to
        // something other than "disabled".
        //
        // If the track is already showing, then we should keep it as showing. But if
        // it something else, we will use hidden so that we don't "flash" cues on the
        // screen.
        let oldState = track.mode;
        let tempState = oldState == 'showing' ? 'showing' : 'hidden';
        track.mode = tempState;
        goog.asserts.assert(
            track.cues,
            'Cues should be accessible when mode is set to "' + tempState + '".');
        // Go backward so that if a removal is done, it should not cause problems
        // with future indexing. In the case that the underlying implementation
        // returns a copy (and not a shared instance) cache a copy of the tracks.
        let cues = track.cues;
        for (let i = cues.length - 1; i >= 0; i--) {
        let cue = cues[i];
        if (cue && predicate(cue)) {
            track.removeCue(cue);
        }
        }
        track.mode = oldState;
    };
    /**
        * @const {string}
        * @private
        */
    CustomTextDisplayer.TextTrackLabel_ = 'Custom TextTrack';
    
   </script>

    <script>

        const channel = 'urn:x-cast:com.optm.anhplayer';
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();
        const licenseServerUrl = "https://ios.orangetv.orange.es/mob/api/rtv/v1/drm";
        var cookies = [];
        var username = "";
        var password = "";
        var senderId = "";

        var startTime = 0;

        console.log("context getInstance()")

        const options = new cast.framework.CastReceiverOptions();
        
        options.customNamespaces = {
            [channel]: cast.framework.system.MessageType.JSON
        };
        
        //context.start(options);



        // Update playback config licenseUrl according to provided value in load request.
        playerManager.setMediaPlaybackInfoHandler((loadRequest, playbackConfig) => {


            console.log("setMediaPlaybackInfoHandler: " + JSON.stringify(loadRequest.media));


            if (loadRequest.media.startAbsoluteTime) {
                console.log("startAbsoluteTime:" + loadRequest.media.startAbsoluteTime);
                startTime = loadRequest.media.startAbsoluteTime;
            }

            if (loadRequest.media.customData) {


                playbackConfig.licenseCustomData = loadRequest.media.customData;


                /*
                if (loadRequest.media.customData.licenseUrl) {
                    //playbackConfig.licenseUrl = loadRequest.media.customData.licenseUrl;
                    playbackConfig.licenseUrl = licenseServerUrl;
                    console.log("licenseUrl: " + loadRequest.media.customData.licenseUrl);
                }
                if (loadRequest.media.customData.protectionSystem) {
                    console.log("protectionSystem: " + loadRequest.media.customData.protectionSystem);
                    if (loadRequest.media.customData.protectionSystem === "WIDEVINE") {
                        playbackConfig.protectionSystem = cast.framework.ContentProtection.WIDEVINE;
                    } else
                        if (loadRequest.media.customData.protectionSystem === "PLAYREADY"){
                            playbackConfig.protectionSystem = cast.framework.ContentProtection.PLAYREADY;
                        }
                }
                if (loadRequest.media.customData.cookies) {
                    console.log("cookies: " + loadRequest.media.customData.cookies);
                    cookies = loadRequest.media.customData.cookies;
                }
                if (loadRequest.media.customData.licenseCustomData) {
                    console.log("licenseCustomData: " + loadRequest.media.customData.licenseCustomData);
                    playbackConfig.licenseCustomData = loadRequest.media.customData.licenseCustomData;
                }
                */
            }

            return playbackConfig;
        });


        playerManager.addEventListener(cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
            event => {

                console.log("on PLAYER_LOAD_COMPLETE: contentId " + event.media.contentId);

                for (var i = 0; i < event.media.tracks.length; i++) {

                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].language " + event.media.tracks[i].language);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].name: " + event.media.tracks[i].name);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].subtype: " + event.media.tracks[i].subtype);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackContentId: " + event.media.tracks[i].trackContentId);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackContentType: " + event.media.tracks[i].trackContentType);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackId: " + event.media.tracks[i].trackId);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].type: " + event.media.tracks[i].type);
                }


                console.log("PLAYER_LOAD_COMPLETE: ");
                playerManager.play();

                setInterval(checkSubtitles, 5000);

                //console.log("PLAYER_LOAD_COMPLETE: seekTime " + startTime);
                //playerManager.seek(startTime);

                console.log("PLAYER_LOAD_COMPLETE: " + JSON.stringify(event.media))


                if (event.media.startAbsoluteTime){
                    console.log("PLAYER_LOAD_COMPLETE startTime: " + event.media.startAbsoluteTime);
                    playerManager.seek(event.media.startAbsoluteTime);
                }

                sendMessageToSender()
                
            }
        );

        
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            request => {
                console.log("----- LOAD -----");
                // Resolve entity to content id


                playerManager.play();
                /*
                console.log("----- LOAD ----- media: " + JSON.stringify(request.media));


                for (var prop in request.media) {
                    if (Object.prototype.hasOwnProperty.call(request.media, prop)) {
                        console.log("prop: " + prop + " - " + request.media[prop])
                    }
                }
                */

                if (request.media.entity && !request.media.contentId) {

                    //console.log("----- LOAD ----- contentId " + request.media.contentId);
                    return getMediaByEntity(request.media.entity).then(
                        media => {
                        request.media.contentId = media.url;
                        return request;
                        });
            }
            return request;
        });



        function sendMessageToSender(){
            console.log("sendMessageToSender");


            var message = "test"
            context.sendCustomMessage(channel, senderId, message);
        }


        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, event => {
            console.log("on SENDER_DISCONNECTED: " + event.type);
            console.log("SENDER_CONNECTED" + event.senderId)
            senderId = event.senderId

            sendMessageToSender()
        });

        const playbackConfig = new cast.framework.PlaybackConfig();
        playbackConfig.autoResumeDuration = 5;
        playbackConfig.licenseUrl = licenseServerUrl;

        // A hook on the license request url
        playbackConfig.licenseRequestHandler = requestInfo => {
            
            console.log("licenseRequestHandler: " + requestInfo.url);

            /*
            if (cookies.length != 0) {
                cookies.forEach(value => {
                    cookieName = value.split("=")[0];
                    cookieValue = value.split("=")[1];
                    requestInfo.headers[cookieName] = cookieValue;
                    addToLog("cookieName: " + cookieName);
                });
            }
            */

            return requestInfo;
        };



        playerManager.addEventListener(cast.framework.events.EventType.MEDIA_STATUS,
            event => {
                
                console.log("on MEDIA_STATUS: " + event.mediaStatus.playerState);
                if (event.mediaStatus.activeTrackIds) {
                    console.log("on MEDIA_STATUS: number of active track " + event.mediaStatus.activeTrackIds.length);
                    if (event.mediaStatus.activeTrackIds.length >= 1) {
                        console.log("on MEDIA_STATUS: first trackId " + event.mediaStatus.activeTrackIds[0]);
                        if (event.mediaStatus.activeTrackIds.length == 2) {
                            console.log("on MEDIA_STATUS: second trackId " + event.mediaStatus.activeTrackIds[1]);
                        }
                    }
                }
            }
        );

        /* For error code description */
        /* event.detailedErrorCode: https://developers.google.com/cast/docs/reference/caf_receiver/cast.framework.events#.DetailedErrorCode */
        /* mpl errors: https://developers.google.com/cast/docs/mpl_error_codes */
        /* shaka errors: https://shaka-player-demo.appspot.com/docs/api/shaka.util.Error.html */
        playerManager.addEventListener(cast.framework.events.EventType.ERROR,
            event => {
                var errorCodeAsStr = "";
                var errorCodeExtentionAsStr = "";

                console.error("Error " + cast.framework.events.EventType.ERROR)

                switch (event.detailedErrorCode) {
                    case cast.framework.events.DetailedErrorCode.MEDIA_UNKNOWN:
                        errorCodeAsStr = "MEDIA_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode +
                                                    " MediaError code from the video element = " + event.error.shakaErrorData[0] +
                                                    " Description is " + event.error.shakaErrorData[2];

                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_ABORTED:
                        errorCodeAsStr = "MEDIA_ABORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_DECODE:
                        errorCodeAsStr = "MEDIA_DECODE";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_NETWORK:
                        errorCodeAsStr = "MEDIA_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_SRC_NOT_SUPPORTED:
                        errorCodeAsStr = "MEDIA_SRC_NOT_SUPPORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.SOURCE_BUFFER_FAILURE:
                        errorCodeAsStr = "SOURCE_BUFFER_FAILURE";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_UNKNOWN:
                        errorCodeAsStr = "MEDIAKEYS_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode;
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_NETWORK:
                        errorCodeAsStr = "MEDIAKEYS_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_UNSUPPORTED:
                        errorCodeAsStr = "MEDIAKEYS_UNSUPPORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_WEBCRYPTO:
                        errorCodeAsStr = "MEDIAKEYS_WEBCRYPTO";
                        break;
                    case cast.framework.events.DetailedErrorCode.NETWORK_UNKNOWN:
                        errorCodeAsStr = "NETWORK_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.SEGMENT_NETWORK:
                        errorCodeAsStr = "SEGMENT_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_MASTER_PLAYLIST:
                        errorCodeAsStr = "HLS_NETWORK_MASTER_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_PLAYLIST:
                        errorCodeAsStr = "HLS_NETWORK_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_NO_KEY_RESPONSE:
                        errorCodeAsStr = "HLS_NETWORK_NO_KEY_RESPONSE";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_KEY_LOAD:
                        errorCodeAsStr = "HLS_NETWORK_KEY_LOAD";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_INVALID_SEGMENT:
                        errorCodeAsStr = "HLS_NETWORK_INVALID_SEGMENT";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_SEGMENT_PARSING:
                        errorCodeAsStr = "HLS_SEGMENT_PARSING";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_NETWORK:
                        errorCodeAsStr = "DASH_NETWORK";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode +
                                " url = " + event.error.shakaErrorData[0];
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_NO_INIT:
                        errorCodeAsStr = "DASH_NO_INIT";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_NETWORK:
                        errorCodeAsStr = "SMOOTH_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_NO_MEDIA_DATA:
                        errorCodeAsStr = "SMOOTH_NO_MEDIA_DATA";
                        break;
                    case cast.framework.events.DetailedErrorCode.MANIFEST_UNKNOWN:
                        errorCodeAsStr = "MANIFEST_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_MANIFEST_MASTER:
                        errorCodeAsStr = "HLS_MANIFEST_MASTER";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_MANIFEST_PLAYLIST:
                        errorCodeAsStr = "HLS_MANIFEST_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_UNKNOWN:
                        errorCodeAsStr = "DASH_MANIFEST_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode;
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_PERIODS:
                        errorCodeAsStr = "MEDIA_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_UNKNOWN:
                        errorCodeAsStr = "DASH_MANIFEST_NO_PERIODS";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_MIMETYPE:
                        errorCodeAsStr = "DASH_MANIFEST_NO_MIMETYPE";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_INVALID_SEGMENT_INFO:
                        errorCodeAsStr = "DASH_INVALID_SEGMENT_INFO";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_MANIFEST:
                        errorCodeAsStr = "SMOOTH_MANIFEST";
                        break;
                    case cast.framework.events.DetailedErrorCode.SEGMENT_UNKNOWN:
                        errorCodeAsStr = "SEGMENT_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.TEXT_UNKNOWN:
                        errorCodeAsStr = "TEXT_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.APP:
                        errorCodeAsStr = "APP";
                        break;
                    case cast.framework.events.DetailedErrorCode.BREAK_CLIP_LOADING_ERROR:
                        errorCodeAsStr = "BREAK_CLIP_LOADING_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.BREAK_SEEK_INTERCEPTOR_ERROR:
                        errorCodeAsStr = "BREAK_SEEK_INTERCEPTOR_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.IMAGE_ERROR:
                        errorCodeAsStr = "IMAGE_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.LOAD_INTERRUPTED:
                        errorCodeAsStr = "LOAD_INTERRUPTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.LOAD_FAILED:
                        errorCodeAsStr = "LOAD_FAILED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_ERROR_MESSAGE:
                        errorCodeAsStr = "MEDIA_ERROR_MESSAGE";
                        if (event.error.requestId !== undefined)
                            console.log("error.requestId: " + event.error.requestId);
                        if (event.error.type !== undefined)
                            console.log("error.type: " + event.error.type);
                        break;
                    case cast.framework.events.DetailedErrorCode.GENERIC:
                        errorCodeAsStr = "GENERIC";
                        break;
                    default:
                        errorCodeAsStr = "Unexpected error code" ;
                        break;

                }
                console.log("on ERROR: " + errorCodeAsStr + "(" + errorCodeExtentionAsStr + ")");

                // report the error to the device
                var errorMsg = {type: 'playbackerror'};
                errorMsg.errorCode = event.detailedErrorCode;
                errorMsg.errorCodeAsStr = errorCodeAsStr + ". " + errorCodeExtentionAsStr;
                context.sendCustomMessage(channel, undefined, errorMsg);

                // stop the player
                if ( playerManager.getPlayerState() !== cast.framework.messages.PlayerState.IDLE ) {
                    playerManager.stop();
                }

                // stop the session
                context.stop();
            }
        );

        // A hook on the manifest when downloaded and parsed
        playbackConfig.manifestHandler = manifest => {
            console.log("manifestHandler: " + manifest);
            return manifest;
        };
        // A hook on the manifest request url
        playbackConfig.manifestRequestHandler = networkRequestInfo => {
            console.log("manifestRequestHandler: " + networkRequestInfo.url);
            return networkRequestInfo;
        };

        context.addCustomMessageListener(channel, function(customEvent) {
            console.log("addCustomMessageListener");
            var message = customEvent.data;
            var command = message.command;
            var params = message.params;

            if (command == "login"){
                loginWithParams(params);
            }else{
                var text = params.text
                var log = "Message received from " + 
                            "[" +  customEvent.senderId +  "],  " +
                            " command: " + command + 
                            " text: " + text;
                console.log(log);
            }
          });


        options.playbackConfig = playbackConfig;
        context.start(options);

        console.log("context started")



        function loginWithParams(params){
            username = params.username;
            password = params.password;
            postLogin();
        }

        function postLogin(){
            console.log("postLogin");
            var xhttp = new XMLHttpRequest();
            xhttp.open("POST", "https://orangetv.orange.es/mob/api/rtv/v1/Login?client=json", true);
            xhttp.withCredentials = true
            xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xhttp.send("username=" + username +"&password=" + password);

            xhttp.onreadystatechange = function() {

                if (this.readyState == 4 && this.status == 200) {
                    console.log("response: " + xhttp.responseText );
                    var status = JSON.parse(xhttp.responseText)["response"]["status"];
                    console.log("response: " + status );


                    sendMessageToSender()
                }
            }

        }


    
    function checkSubtitles() {
        console.log("checkSubtitles");
        var cue = shaka.text.Cue;
        console.log("checkSubtitles check is visible");
        var direction = cue.direction;
        //console.log("checkSubtitles isVisible: " + shaka.text.SimpleTextDisplayer.isTextVisible());
        console.log("checkSubtitles direction " + direction);
        shaka.text.Cue.backgroundColor = "#00FF00"
        shaka.text.Cue.color = "#FFFFFF00"
        shaka.text.Cue.size = 2000
        console.log("checkSubtitles finish");
    }


    console.log("player configure");
    /*
    var player = shaka.player;
    player.configure({
        textDisplayFactory: CustomTextDisplayer
    });
    */
    console.log("player configure 2");
    </script>

</body>
</html>