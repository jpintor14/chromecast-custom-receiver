<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="stylesheet" href="receiver.05.05.20.css" media="screen" />
</head>
<body style="width: 100%;">

    <cast-media-player style="width: 100%;" id="player"></cast-media-player>

    <!-- fingerprint -->
    <div id="fingerprint" style="color: red; 
                                z-index: 9999; 
                                position: absolute; 
                                float: left; 
                                background-color: black; 
                                color: white; 
                                margin-left: 5%; 
                                margin-top: 5%; 
                                font-size: 20px;
                                padding: 5px 20px 5px 20px; 
                                border-radius: 5px;
                                visibility: hidden;">00000000</div>

    <!--<script type="text/javascript" src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"> </script>-->
    <script type="text/javascript" src="receiver2.5.8.js"> </script>
    <script type="text/javascript" src="WasABI.js"> </script>
    <script>

        const wasAbi = new WasABI();
        const channel = wasAbi.getChannel();
        const licenseServerUrl = wasAbi.getLicenseUrl();
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();
        var username = "";
        var password = "";
        var senderId = "";
        var startTime = 0;
        var sessionManagerTimer = null;
        var markPositionTimer = null;
        var showFingerPrintTimeout = null;
        var hideFingerPrintTimeout = null;
        var secondaryQaaLanguage = "eng";
        var notQaaLanguage = "spa";

        console.log("context getInstance()");

        const options = new cast.framework.CastReceiverOptions();
        
        options.customNamespaces = {
            [channel]: cast.framework.system.MessageType.JSON
        };
        

        // Update playback config licenseUrl according to provided value in load request.
        playerManager.setMediaPlaybackInfoHandler((loadRequest, playbackConfig) => {


            console.log("setMediaPlaybackInfoHandler: " + JSON.stringify(loadRequest.media));


            if (loadRequest.media.startAbsoluteTime) {
                console.log("startAbsoluteTime:" + loadRequest.media.startAbsoluteTime);
                startTime = loadRequest.media.startAbsoluteTime;
            }

            if (loadRequest.media.customData) {
                playbackConfig.licenseCustomData = loadRequest.media.customData;
            }

            return playbackConfig;
        });


        playerManager.addEventListener(cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
            event => {

                console.log("on PLAYER_LOAD_COMPLETE: contentId " + event.media.contentId);

                console.log("PLAYER_LOAD_COMPLETE: ");

                playerManager.play();
                scheduleTimerMarkPosition();
                scheduleTimerOpenSession();



                for (var i = 0; i < event.media.tracks.length; i++) {
                    
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].language " + event.media.tracks[i].language);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].name: " + event.media.tracks[i].name);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].subtype: " + event.media.tracks[i].subtype);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackContentId: " + event.media.tracks[i].trackContentId);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackContentType: " + event.media.tracks[i].trackContentType);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].trackId: " + event.media.tracks[i].trackId);
                    console.log("on PLAYER_LOAD_COMPLETE: tracks[" + i + "].type: " + event.media.tracks[i].type);

                }

                setDefaultLanguage(event.media.tracks);
                setDefaultSubtitles(event.media.tracks);


                console.log("PLAYER_LOAD_COMPLETE: " + JSON.stringify(event.media));


                if (event.media.startAbsoluteTime){
                    console.log("PLAYER_LOAD_COMPLETE startTime: " + event.media.startAbsoluteTime);
                    playerManager.seek(event.media.startAbsoluteTime);
                }

                sendMessageToSender();
                adjustPlayAfterLoad()
                
            }
        );

        playerManager.addEventListener(cast.framework.events.EventType.SEEKED,
            event => {
                console.log("CUSTOM LOG: event seeked");
                updateMarkPosition();
            }
        );

        playerManager.addEventListener(cast.framework.events.EventType.ENDED,
            event => {
                console.log("CUSTOM LOG: event ended");
                playEnded();
            }
        );

        /*
        playerManager.addEventListener(cast.framework.events.EventType.ABORT,
            event => {
                console.log("CUSTOM LOG: event abort");
                playEnded();
            }
        );
        */

        playerManager.addEventListener(cast.framework.events.EventType.REQUEST_STOP,
            event => {
                console.log("CUSTOM LOG: event request_stop");
                playEnded();
            }
        );

        playerManager.addEventListener(cast.framework.events.EventType.LIVE_ENDED,
            event => {
                console.log("CUSTOM LOG: event live_ended");
                playerManager.stop()
                playEnded();
            }
        );

        playerManager.setMessageInterceptor(cast.framework.messages.MessageType.EDIT_AUDIO_TRACKS, request => {
            
            console.log("PLAYER_LOAD_COMPLETE: setMessageInterceptor EDIT_AUDIO_TRACKS " + JSON.stringify(request));


            for (var i = 0; i < request.tracks; i++) {
                if (request.tracks[i].type == "AUDIO"){
                    console.log("PLAYER_LOAD_COMPLETE: setMessageInterceptor AUDIO_TRACK " + request.tracks[i].name);
                    request.tracks[i].name = wasAbi.getLanguageName(request.tracks[i].name);
                    console.log("PLAYER_LOAD_COMPLETE: setMessageInterceptor getLanguageName AUDIO_TRACK " + request.tracks[i].name);
                }
            }
        });

        
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            request => {
                console.log("----- LOAD -----");
                // Resolve entity to content id


                playerManager.play();
                
                console.log("----- LOAD ----- media: " + JSON.stringify(request.media));


                for (var prop in request.media) {
                    if (Object.prototype.hasOwnProperty.call(request.media, prop)) {
                        console.log("prop: " + prop + " - " + request.media[prop])
                    }
                }
                

                if (request.media.entity && !request.media.contentId) {
                    return getMediaByEntity(request.media.entity).then(
                        media => {
                        request.media.contentId = media.url;
                        return request;
                        });
            }
            return request;
        });


        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, event => {
            console.log("on SENDER_DISCONNECTED: " + event.type);
            console.log("SENDER_CONNECTED" + event.senderId)
            senderId = event.senderId;

            sendMessageToSender();
        });

        const playbackConfig = new cast.framework.PlaybackConfig();
        playbackConfig.autoResumeDuration = 5;
        playbackConfig.licenseUrl = licenseServerUrl;



        // A hook on the license request url
        playbackConfig.licenseRequestHandler = requestInfo => {
            
            console.log("licenseRequestHandler: " + requestInfo.url);
            return requestInfo;
        };


        /* For error code description */
        /* event.detailedErrorCode: https://developers.google.com/cast/docs/reference/caf_receiver/cast.framework.events#.DetailedErrorCode */
        /* mpl errors: https://developers.google.com/cast/docs/mpl_error_codes */
        /* shaka errors: https://shaka-player-demo.appspot.com/docs/api/shaka.util.Error.html */
        playerManager.addEventListener(cast.framework.events.EventType.ERROR,
            event => {
                var errorCodeAsStr = "";
                var errorCodeExtentionAsStr = "";

                console.error("Error " + cast.framework.events.EventType.ERROR)

                switch (event.detailedErrorCode) {
                    case cast.framework.events.DetailedErrorCode.MEDIA_UNKNOWN:
                        errorCodeAsStr = "MEDIA_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode +
                                                    " MediaError code from the video element = " + event.error.shakaErrorData[0] +
                                                    " Description is " + event.error.shakaErrorData[2];

                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_ABORTED:
                        errorCodeAsStr = "MEDIA_ABORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_DECODE:
                        errorCodeAsStr = "MEDIA_DECODE";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_NETWORK:
                        errorCodeAsStr = "MEDIA_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_SRC_NOT_SUPPORTED:
                        errorCodeAsStr = "MEDIA_SRC_NOT_SUPPORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.SOURCE_BUFFER_FAILURE:
                        errorCodeAsStr = "SOURCE_BUFFER_FAILURE";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_UNKNOWN:
                        errorCodeAsStr = "MEDIAKEYS_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode;
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_NETWORK:
                        errorCodeAsStr = "MEDIAKEYS_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_UNSUPPORTED:
                        errorCodeAsStr = "MEDIAKEYS_UNSUPPORTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIAKEYS_WEBCRYPTO:
                        errorCodeAsStr = "MEDIAKEYS_WEBCRYPTO";
                        break;
                    case cast.framework.events.DetailedErrorCode.NETWORK_UNKNOWN:
                        errorCodeAsStr = "NETWORK_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.SEGMENT_NETWORK:
                        errorCodeAsStr = "SEGMENT_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_MASTER_PLAYLIST:
                        errorCodeAsStr = "HLS_NETWORK_MASTER_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_PLAYLIST:
                        errorCodeAsStr = "HLS_NETWORK_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_NO_KEY_RESPONSE:
                        errorCodeAsStr = "HLS_NETWORK_NO_KEY_RESPONSE";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_KEY_LOAD:
                        errorCodeAsStr = "HLS_NETWORK_KEY_LOAD";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_NETWORK_INVALID_SEGMENT:
                        errorCodeAsStr = "HLS_NETWORK_INVALID_SEGMENT";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_SEGMENT_PARSING:
                        errorCodeAsStr = "HLS_SEGMENT_PARSING";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_NETWORK:
                        errorCodeAsStr = "DASH_NETWORK";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode +
                                " url = " + event.error.shakaErrorData[0];
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_NO_INIT:
                        errorCodeAsStr = "DASH_NO_INIT";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_NETWORK:
                        errorCodeAsStr = "SMOOTH_NETWORK";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_NO_MEDIA_DATA:
                        errorCodeAsStr = "SMOOTH_NO_MEDIA_DATA";
                        break;
                    case cast.framework.events.DetailedErrorCode.MANIFEST_UNKNOWN:
                        errorCodeAsStr = "MANIFEST_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_MANIFEST_MASTER:
                        errorCodeAsStr = "HLS_MANIFEST_MASTER";
                        break;
                    case cast.framework.events.DetailedErrorCode.HLS_MANIFEST_PLAYLIST:
                        errorCodeAsStr = "HLS_MANIFEST_PLAYLIST";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_UNKNOWN:
                        errorCodeAsStr = "DASH_MANIFEST_UNKNOWN";
                        if ( (event.error !== undefined) && (event.error.shakaErrorCode !== undefined) )
                            errorCodeExtentionAsStr = "ShakaPlayer error code = " + event.error.shakaErrorCode;
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_PERIODS:
                        errorCodeAsStr = "MEDIA_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_UNKNOWN:
                        errorCodeAsStr = "DASH_MANIFEST_NO_PERIODS";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_MANIFEST_NO_MIMETYPE:
                        errorCodeAsStr = "DASH_MANIFEST_NO_MIMETYPE";
                        break;
                    case cast.framework.events.DetailedErrorCode.DASH_INVALID_SEGMENT_INFO:
                        errorCodeAsStr = "DASH_INVALID_SEGMENT_INFO";
                        break;
                    case cast.framework.events.DetailedErrorCode.SMOOTH_MANIFEST:
                        errorCodeAsStr = "SMOOTH_MANIFEST";
                        break;
                    case cast.framework.events.DetailedErrorCode.SEGMENT_UNKNOWN:
                        errorCodeAsStr = "SEGMENT_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.TEXT_UNKNOWN:
                        errorCodeAsStr = "TEXT_UNKNOWN";
                        break;
                    case cast.framework.events.DetailedErrorCode.APP:
                        errorCodeAsStr = "APP";
                        break;
                    case cast.framework.events.DetailedErrorCode.BREAK_CLIP_LOADING_ERROR:
                        errorCodeAsStr = "BREAK_CLIP_LOADING_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.BREAK_SEEK_INTERCEPTOR_ERROR:
                        errorCodeAsStr = "BREAK_SEEK_INTERCEPTOR_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.IMAGE_ERROR:
                        errorCodeAsStr = "IMAGE_ERROR";
                        break;
                    case cast.framework.events.DetailedErrorCode.LOAD_INTERRUPTED:
                        errorCodeAsStr = "LOAD_INTERRUPTED";
                        break;
                    case cast.framework.events.DetailedErrorCode.LOAD_FAILED:
                        errorCodeAsStr = "LOAD_FAILED";
                        break;
                    case cast.framework.events.DetailedErrorCode.MEDIA_ERROR_MESSAGE:
                        errorCodeAsStr = "MEDIA_ERROR_MESSAGE";
                        if (event.error.requestId !== undefined)
                            console.log("error.requestId: " + event.error.requestId);
                        if (event.error.type !== undefined)
                            console.log("error.type: " + event.error.type);
                        break;
                    case cast.framework.events.DetailedErrorCode.GENERIC:
                        errorCodeAsStr = "GENERIC";
                        break;
                    default:
                        errorCodeAsStr = "Unexpected error code" ;
                        break;

                }
                console.log("on ERROR: " + errorCodeAsStr + "(" + errorCodeExtentionAsStr + ")");

                // report the error to the device
                var errorMsg = {type: 'playbackerror'};
                errorMsg.errorCode = event.detailedErrorCode;
                errorMsg.errorCodeAsStr = errorCodeAsStr + ". " + errorCodeExtentionAsStr;
                context.sendCustomMessage(channel, undefined, errorMsg);

                // stop the player
                if ( playerManager.getPlayerState() !== cast.framework.messages.PlayerState.IDLE ) {
                    playerManager.stop();
                }

                // stop the session
                context.stop();
                wasAbi.closeSession()
            }
        );

        // A hook on the manifest when downloaded and parsed
        playbackConfig.manifestHandler = manifest => {
            console.log("manifestHandler: " + manifest);
            return manifest;
        };
        // A hook on the manifest request url
        playbackConfig.manifestRequestHandler = networkRequestInfo => {
            console.log("manifestRequestHandler: " + networkRequestInfo.url);
            return networkRequestInfo;
        };

        context.addCustomMessageListener(channel, function(customEvent) {
            var message = customEvent.data;
            var command = message.command;
            var params = message.params;


            console.log("CUSTOM LOG: custom message: " + JSON.stringify(message));

            switch (command) {
                case "login":
                    wasAbi.login(params);
                    break;
                case "sessionParams":
                    wasAbi.initSessionParams(params);
                    checkFingerPrint();
                    break;
                case "requestSessionParams":
                    sendSessionParams();
                    break;
                default:
                    customMessageReceiver(params, command);
                    break;
            }

          });


        options.playbackConfig = playbackConfig;
        context.start(options);

        console.log("CUSTOM LOG:context started");

        function customMessageReceiver(params, senderId){
            var command = message.command;
            var text = params.text;
            var log = "Message received from " + 
                        "[" +  senderId +  "],  " +
                        " command: " + command + 
                        " text: " + text;
            console.log(log);
        }


        function sendMessageToSender(){
            console.log("sendMessageToSender");
            var message = "test";
            context.sendCustomMessage(channel, senderId, message);
        }

        function adjustPlayAfterLoad(){
            var contentInfo = wasAbi.getContentInfo()
            if (contentInfo.type == "stov")
            {
                playerManager.seek(0)
            }
        }


        function sendSessionParams(){
            var contentInfo = wasAbi.getContentInfo();
            console.log("CUSTOM LOG: sendSessionParams: " + JSON.stringify(contentInfo));

            var message = { "command": "sessionParams",
                            "data": contentInfo };

            context.sendCustomMessage(channel, senderId, message);
        }

        
        function scheduleTimerOpenSession(){
            console.log("CUSTOM LOG: openSession:  schedule");
            if (sessionManagerTimer != null){
                closeSession();
            }

            openSession();
            sessionManagerTimer = setInterval(openSession, wasAbi.getSessionManagerInterval());
            console.log("CUSTOM LOG: openSession: schedule 2");
        }

        function openSession(){
            console.log("CUSTOM LOG: openSession:  interval");
            wasAbi.openSession(wasAbi);
        }

        function closeSession(){
            wasAbi.closeSession();
            clearInterval(sessionManagerTimer);
            console.log("CUSTOM LOG: closeSession");
        }
        

        function scheduleTimerMarkPosition(){
            if (markPositionTimer != null){
                clearInterval(markPositionTimer);
            }

            // live and trailer will not send mark position
            if (!wasAbi.isPlayingLive() && !wasAbi.isPlayingTrailer()){
                //execute first time now
                updateMarkPosition();
                markPositionTimer = setInterval(updateMarkPosition, wasAbi.getSessionManagerInterval());
            }
        }

        function updateMarkPosition() {
            // live and trailer will not send mark position
            if (!wasAbi.isPlayingLive() && !wasAbi.isPlayingTrailer()){
                console.log("CUSTOM LOG: index updateMarkPosition: ");
                var position = parseInt(playerManager.getCurrentTimeSec()) * 1000;
                console.log("CUSTOM LOG: index updateMarkPosition: " + position);
                wasAbi.markPosition(position)
            }
        }

        //set default audio language (updated from the server)
        function setDefaultLanguage(tracks){
            if (wasAbi.getDefaultAudioLanguage() == "qaa"){
                var qaaFound = false;

                //search qaa
                for (var i = 0; i < tracks.length; i++) {
                    if (tracks[i].type == "AUDIO" && tracks[i].language == wasAbi.getDefaultAudioLanguage()){
                        playerManager.getAudioTracksManager().setActiveByLanguage(tracks[i].language);
                        qaaFound = true;
                    }
                }

                //search secondary qaa language (eng)
                if (!qaaFound){
                    for (var i = 0; i < tracks.length; i++) {
                        if (tracks[i].type == "AUDIO" && tracks[i].language == secondaryQaaLanguage){
                            playerManager.getAudioTracksManager().setActiveByLanguage(tracks[i].language);
                            qaaFound = true;
                        }
                    }
                }

                //set first language except spanish
                if (!qaaFound){
                    for (var i = 0; i < tracks.length; i++) {
                        if (!qaaFound && tracks[i].type == "AUDIO" && tracks[i].language != notQaaLanguage){
                            playerManager.getAudioTracksManager().setActiveByLanguage(tracks[i].language);
                            qaaFound = true;
                        }
                    }
                }

            }else{
                //if  selected language is not qaa try to set automatically
                for (var i = 0; i < tracks.length; i++) {
                    if (tracks[i].type == "AUDIO" && tracks[i].language == wasAbi.getDefaultAudioLanguage()){
                        playerManager.getAudioTracksManager().setActiveByLanguage(tracks[i].language);
                    }
                }
            }
        }

        //set default subtitles language (updated from the server)
        function setDefaultSubtitles(tracks){

            if (wasAbi.getDefaultSubtitlesLanguage() == "qaa"){
                var qaaFound = false;

                //search qaa
                for (var i = 0; i < tracks.length; i++) {
                    if (tracks[i].type == "TEXT" && tracks[i].language == wasAbi.getDefaultSubtitlesLanguage()){
                        playerManager.getTextTracksManager().setActiveByLanguage(tracks[i].language);
                        qaaFound = true;
                    }
                }

                //search secondary qaa language (eng)
                if (!qaaFound){
                    for (var i = 0; i < tracks.length; i++) {
                        if (tracks[i].type == "TEXT" && tracks[i].language == secondaryQaaLanguage){
                            playerManager.getTextTracksManager().setActiveByLanguage(tracks[i].language);
                            qaaFound = true;
                        }
                    }
                }

                //set first language except spanish
                if (!qaaFound){
                    for (var i = 0; i < tracks.length; i++) {
                        if (!qaaFound && tracks[i].type == "TEXT" && tracks[i].language != notQaaLanguage){
                        playerManager.getTextTracksManager().setActiveByLanguage(tracks[i].language);
                            qaaFound = true;
                        }
                    }
                }

            }else{
                //if  selected language is not qaa try to set automatically
                for (var i = 0; i < tracks.length; i++) {
                    if (tracks[i].type == "TEXT" && tracks[i].language == wasAbi.getDefaultSubtitlesLanguage()){
                        playerManager.getTextTracksManager().setActiveByLanguage(tracks[i].language);
                    }
                }
            }

        }


        function playEnded(){
            closeSession();
            if (markPositionTimer != null){
                clearInterval(markPositionTimer);
            }
            hideFingerprint();
        }

        function checkFingerPrint(){
            
            clearTimeout(hideFingerPrintTimeout);
            clearTimeout(showFingerPrintTimeout);

            if(wasAbi.hasFingerprint()){
                showFingerprint();
            }else{
                hideFingerprint();
            }
        }

        function showFingerprint(){
            if(wasAbi.hasFingerprint()) {
                console.log("CUSTOM LOG: showFingerprint hasFingerprint");
                var position = wasAbi.getRandomFingerprintPosition();



                console.log("CUSTOM LOG: showFingerprint position" + JSON.stringify(position));
                console.log("CUSTOM LOG: showFingerprint horizontal" + position.horizontal + "%");
                console.log("CUSTOM LOG: showFingerprint vertical" + position.vertical + "%");

                document.getElementById("fingerprint").style.marginLeft = position.horizontal + "%";
                document.getElementById("fingerprint").style.marginTop = position.vertical + "%";
                document.getElementById("fingerprint").style.visibility = "visible";
                document.getElementById("fingerprint").innerHTML = wasAbi.getHouseholdId();
                scheduleHideFingerprint();
            }
        }

        function hideFingerprint(){
            document.getElementById("fingerprint").style.visibility = "hidden";
            if(wasAbi.hasFingerprint()){
                scheduleShowFingerprint();
            }
        }

        function scheduleHideFingerprint(){
            hideFingerPrintTimeout = setTimeout(hideFingerprint, wasAbi.getFingerprintDuration());
        }

        function scheduleShowFingerprint(){
            showFingerPrintTimeout = setTimeout(showFingerprint, wasAbi.getFingerprintPeriod());
        }
        

    </script>

</body>
</html>